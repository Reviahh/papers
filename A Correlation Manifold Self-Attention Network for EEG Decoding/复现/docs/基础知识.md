# èŒƒç•´è®ºè§†è§’ä¸‹çš„çº¿æ€§ä»£æ•° Ã— CorAttè®ºæ–‡è§£æ

## ç¬¬ä¸€éƒ¨åˆ†ï¼šèŒƒç•´è®ºåŸºç¡€ = ã€Œæ¸¸æˆå¼•æ“çš„è®¾è®¡æ¨¡å¼ã€

### 1. ä»€ä¹ˆæ˜¯èŒƒç•´ï¼Ÿ

**èŒƒç•´ = å¯¹è±¡ + ç®­å¤´ + ç»„åˆè§„åˆ™**

```
æƒ³è±¡ä½ åœ¨è®¾è®¡æ¸¸æˆå¼•æ“çš„ç±»å‹ç³»ç»Ÿï¼š

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    èŒƒç•´ Category                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  å¯¹è±¡ (Objects)     â”‚  æ¸¸æˆä¸­çš„ã€Œç±»å‹ã€                   â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  æ€å°„ (Morphisms)   â”‚  ç±»å‹ä¹‹é—´çš„ã€Œè½¬æ¢å‡½æ•°ã€              â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  ç»„åˆ (Composition) â”‚  å‡½æ•°å¯ä»¥ä¸²è”ï¼šfâˆ˜g                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚  æ’ç­‰ (Identity)    â”‚  æ¯ä¸ªç±»å‹æœ‰ã€Œä»€ä¹ˆéƒ½ä¸åšã€çš„å‡½æ•°       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# èŒƒç•´çš„ä»£ç ç›´è§‰

# å¯¹è±¡ = ç±»å‹
class Vector: pass
class Matrix: pass
class Scalar: pass

# æ€å°„ = å‡½æ•°ç­¾å
def dot_product(v1: Vector, v2: Vector) -> Scalar: ...
def matrix_vector_mult(M: Matrix, v: Vector) -> Vector: ...
def compose(f, g):  # fâˆ˜g: å…ˆgåf
    return lambda x: f(g(x))

# æ’ç­‰æ€å°„
def identity(x): return x
```

---

### 2. VectèŒƒç•´ï¼šå‘é‡ç©ºé—´çš„ä¸–ç•Œ

```
                     Vect èŒƒç•´ï¼ˆå‘é‡ç©ºé—´èŒƒç•´ï¼‰
    
    å¯¹è±¡ï¼šæ‰€æœ‰å‘é‡ç©ºé—´ (â„Â¹, â„Â², â„Â³, ..., â„â¿, ...)
    
    æ€å°„ï¼šçº¿æ€§æ˜ å°„ï¼ˆçŸ©é˜µï¼ï¼‰
    
         â”Œâ”€â”€â”€â”           â”Œâ”€â”€â”€â”
         â”‚â„Â² â”‚ â”€â”€â”€Aâ”€â”€â”€â†’  â”‚â„Â³ â”‚      Aæ˜¯2Ã—3çŸ©é˜µ
         â””â”€â”€â”€â”˜           â””â”€â”€â”€â”˜
           â”‚               â”‚
           â”‚      B        â”‚
           â”‚    (3Ã—4)      â†“
           â”‚             â”Œâ”€â”€â”€â”
           â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚â„â´ â”‚      Bâˆ˜A æ˜¯å¤åˆæ˜ å°„
                         â””â”€â”€â”€â”˜
    
    ç»„åˆï¼šçŸ©é˜µä¹˜æ³•ï¼  (Bâˆ˜A)(v) = B(A(v))
    æ’ç­‰ï¼šå•ä½çŸ©é˜µ I
```

**å…³é”®æ´è§**ï¼šçŸ©é˜µä¹˜æ³•çš„ç»“åˆå¾‹ `(AB)C = A(BC)` æ­£æ˜¯èŒƒç•´è®ºè¦æ±‚çš„ï¼

```python
import jax.numpy as jnp

# VectèŒƒç•´ä¸­çš„æ€å°„ = çŸ©é˜µ
class LinearMap:
    """VectèŒƒç•´ä¸­çš„æ€å°„"""
    def __init__(self, matrix):
        self.matrix = matrix
    
    def __call__(self, v):
        """åº”ç”¨æ€å°„"""
        return self.matrix @ v
    
    def compose(self, other):
        """æ€å°„ç»„åˆ = çŸ©é˜µä¹˜æ³•"""
        return LinearMap(self.matrix @ other.matrix)
    
    @staticmethod
    def identity(n):
        """æ’ç­‰æ€å°„ = å•ä½çŸ©é˜µ"""
        return LinearMap(jnp.eye(n))

# éªŒè¯èŒƒç•´å…¬ç†
A = LinearMap(jnp.array([[1, 2], [3, 4], [5, 6]]))  # â„Â² â†’ â„Â³
B = LinearMap(jnp.array([[1, 0, 1], [0, 1, 1]]))    # â„Â³ â†’ â„Â²

# ç»“åˆå¾‹
v = jnp.array([1.0, 2.0])
assert jnp.allclose(B(A(v)), B.compose(A)(v))
```

---

### 3. å‡½å­ = èŒƒç•´ä¹‹é—´çš„ã€Œç¿»è¯‘å™¨ã€

**å‡½å­æŠŠä¸€ä¸ªèŒƒç•´ã€Œæ˜ å°„ã€åˆ°å¦ä¸€ä¸ªèŒƒç•´ï¼Œä¿æŒç»“æ„ã€‚**

```
              å‡½å­ F: C â†’ D
    
    èŒƒç•´ C                           èŒƒç•´ D
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚    A    â”‚      F(A)          â”‚  F(A)   â”‚
    â”‚    â”‚    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’       â”‚    â”‚    â”‚
    â”‚    f    â”‚                    â”‚   F(f)  â”‚
    â”‚    â†“    â”‚      F(B)          â”‚    â†“    â”‚
    â”‚    B    â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’       â”‚  F(B)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    è¦æ±‚ï¼šF(fâˆ˜g) = F(f)âˆ˜F(g)   ä¿æŒç»„åˆ
          F(id_A) = id_{F(A)}  ä¿æŒæ’ç­‰
```

**æ¸¸æˆç±»æ¯”**ï¼š

```python
# å‡½å­ = æ¸¸æˆå¼•æ“çš„ã€Œæ¸²æŸ“ç®¡çº¿ã€

class GameWorld:
    """æ¸¸æˆé€»è¾‘èŒƒç•´"""
    pass

class RenderWorld:
    """æ¸²æŸ“èŒƒç•´"""
    pass

class RenderFunctor:
    """
    å‡½å­ï¼šGameWorld â†’ RenderWorld
    æŠŠæ¸¸æˆå¯¹è±¡ã€Œç¿»è¯‘ã€æˆå¯æ¸²æŸ“å¯¹è±¡ï¼Œä¿æŒå…³ç³»
    """
    def map_object(self, game_obj):
        """å¯¹è±¡æ˜ å°„ï¼šè§’è‰² â†’ 3Dæ¨¡å‹"""
        return Mesh(game_obj.model_path)
    
    def map_morphism(self, game_action):
        """æ€å°„æ˜ å°„ï¼šç§»åŠ¨åŠ¨ä½œ â†’ åŠ¨ç”»å˜æ¢"""
        return Animation(game_action.type)
```

---

### 4. è‡ªç„¶å˜æ¢ = å‡½å­ä¹‹é—´çš„ã€Œè½¬æ¢ã€

```
           è‡ªç„¶å˜æ¢ Î·: F âŸ¹ G
    
    ä¸¤ä¸ªå‡½å­ F, G: C â†’ D
    
    å¯¹äºCä¸­æ¯ä¸ªå¯¹è±¡Aï¼Œæœ‰ä¸€ä¸ªæ€å°„ Î·_A: F(A) â†’ G(A)
    
              F(A) â”€â”€â”€Î·_Aâ”€â”€â”€â†’ G(A)
               â”‚               â”‚
             F(f)            G(f)
               â†“               â†“
              F(B) â”€â”€â”€Î·_Bâ”€â”€â”€â†’ G(B)
    
    è¦æ±‚è¿™ä¸ªæ–¹å—ã€Œäº¤æ¢ã€ï¼šG(f) âˆ˜ Î·_A = Î·_B âˆ˜ F(f)
```

**æ¸¸æˆç±»æ¯”**ï¼šä¸¤ç§æ¸²æŸ“ç®¡çº¿ä¹‹é—´çš„æ— ç¼åˆ‡æ¢

```python
# è‡ªç„¶å˜æ¢ = ä¸åŒLODï¼ˆç»†èŠ‚å±‚æ¬¡ï¼‰ä¹‹é—´çš„è½¬æ¢

class HighDetailFunctor:
    """é«˜ç»†èŠ‚æ¸²æŸ“"""
    pass

class LowDetailFunctor:
    """ä½ç»†èŠ‚æ¸²æŸ“"""
    pass

class LODTransition:
    """
    è‡ªç„¶å˜æ¢ï¼šHighDetail âŸ¹ LowDetail
    æ— è®ºå…ˆå˜æ¢å†é™çº§ï¼Œè¿˜æ˜¯å…ˆé™çº§å†å˜æ¢ï¼Œç»“æœä¸€è‡´
    """
    def transform(self, high_detail_obj):
        return simplify_mesh(high_detail_obj)
```

---

## ç¬¬äºŒéƒ¨åˆ†ï¼šçº¿æ€§ä»£æ•°çš„èŒƒç•´è®ºè§†è§’

### 5. æ ¸å¿ƒæ¦‚å¿µçš„èŒƒç•´è®ºè§£é‡Š

| çº¿æ€§ä»£æ•°æ¦‚å¿µ | èŒƒç•´è®ºè§£é‡Š | æ¸¸æˆç±»æ¯” |
|-------------|-----------|---------|
| **å‘é‡ç©ºé—´** | VectèŒƒç•´çš„å¯¹è±¡ | æ¸¸æˆä¸­çš„æ•°æ®ç±»å‹ |
| **çº¿æ€§æ˜ å°„** | VectèŒƒç•´çš„æ€å°„ | ç±»å‹è½¬æ¢å‡½æ•° |
| **çŸ©é˜µä¹˜æ³•** | æ€å°„çš„ç»„åˆ | å‡½æ•°ç»„åˆ |
| **å•ä½çŸ©é˜µ** | æ’ç­‰æ€å°„ | identityå‡½æ•° |
| **å¯é€†çŸ©é˜µ** | åŒæ„ï¼ˆisomorphismï¼‰ | å¯é€†è½¬æ¢ |
| **ç§©** | åƒç©ºé—´çš„ç»´åº¦ | è¾“å‡ºä¿¡æ¯é‡ |
| **æ ¸** | æ€å°„çš„kernel | ä¸¢å¤±çš„ä¿¡æ¯ |
| **ç‰¹å¾å€¼åˆ†è§£** | æ€å°„çš„ä¸åŠ¨ç‚¹ç»“æ„ | ç³»ç»Ÿç¨³å®šçŠ¶æ€ |

### 6. ç§©-é›¶åŒ–åº¦å®šç†çš„èŒƒç•´è®ºè¯æ˜

```
å¯¹äºçº¿æ€§æ˜ å°„ f: V â†’ W

        V â”€â”€â”€â”€â”€â”€fâ”€â”€â”€â”€â”€â”€â†’ W
        â”‚                â”‚
    dim = n          dim = m
        
    V å¯ä»¥åˆ†è§£ä¸ºï¼š
    
        V = Ker(f) âŠ• Im(f)çš„åŸåƒ
            â†“           â†“
         é›¶åŒ–åº¦        ç§©
         
    å®šç†ï¼šdim(V) = dim(Ker(f)) + dim(Im(f))
                 = é›¶åŒ–åº¦ + ç§©
```

```python
def analyze_linear_map(matrix):
    """åˆ†æçº¿æ€§æ˜ å°„çš„èŒƒç•´è®ºå±æ€§"""
    
    # ç§© = åƒç©ºé—´ç»´åº¦
    rank = jnp.linalg.matrix_rank(matrix)
    
    # é›¶åŒ–åº¦ = æ ¸ç©ºé—´ç»´åº¦
    nullity = matrix.shape[1] - rank
    
    # æ ¸ç©ºé—´ï¼ˆKerï¼‰= è¢«æ˜ å°„åˆ°0çš„å‘é‡
    # ä½¿ç”¨SVDæ‰¾æ ¸ç©ºé—´
    U, S, Vh = jnp.linalg.svd(matrix)
    null_space = Vh[rank:]  # å¥‡å¼‚å€¼ä¸º0å¯¹åº”çš„å³å¥‡å¼‚å‘é‡
    
    return {
        "ç§©(åƒçš„ç»´åº¦)": rank,
        "é›¶åŒ–åº¦(æ ¸çš„ç»´åº¦)": nullity,
        "ä¿¡æ¯ä¿ç•™ç‡": rank / matrix.shape[1],
        "æ˜¯å¦å•å°„(injective)": nullity == 0,
        "æ˜¯å¦æ»¡å°„(surjective)": rank == matrix.shape[0],
        "æ˜¯å¦åŒæ„(isomorphism)": nullity == 0 and rank == matrix.shape[0]
    }
```

---

### 7. ç¾¤ä½œä¸ºå•å¯¹è±¡èŒƒç•´

**å…³é”®æ´è§**ï¼šç¾¤ = åªæœ‰ä¸€ä¸ªå¯¹è±¡çš„èŒƒç•´ï¼Œæ‰€æœ‰æ€å°„éƒ½å¯é€†

```
                  ç¾¤ G ä½œä¸ºèŒƒç•´
    
    åªæœ‰ä¸€ä¸ªå¯¹è±¡ï¼šâ€¢
    
    æ€å°„ï¼šç¾¤å…ƒç´  g âˆˆ G
    
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚         â€¢             â”‚
         â”‚      â†—  â†‘  â†–          â”‚
         â”‚    gâ‚   e   gâ‚‚        â”‚
         â”‚      â†˜  â†“  â†™          â”‚
         â”‚        gâ‚ƒ             â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    
    ç»„åˆï¼šç¾¤ä¹˜æ³• gâ‚ âˆ˜ gâ‚‚ = gâ‚gâ‚‚
    æ’ç­‰ï¼šå•ä½å…ƒ e
    é€†ï¼šæ¯ä¸ªæ€å°„éƒ½å¯é€†ï¼ˆç¾¤çš„å®šä¹‰ï¼ï¼‰
```

```python
# ä¸€èˆ¬çº¿æ€§ç¾¤ GL(n) ä½œä¸ºèŒƒç•´

class GL_n:
    """né˜¶ä¸€èˆ¬çº¿æ€§ç¾¤ = å¯é€†nÃ—nçŸ©é˜µ"""
    
    def __init__(self, n):
        self.n = n
    
    def is_element(self, matrix):
        """æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤å…ƒç´ ï¼ˆå¯é€†çŸ©é˜µï¼‰"""
        return jnp.linalg.det(matrix) != 0
    
    def compose(self, g1, g2):
        """ç¾¤ä¹˜æ³• = çŸ©é˜µä¹˜æ³•"""
        return g1 @ g2
    
    def identity(self):
        """å•ä½å…ƒ = å•ä½çŸ©é˜µ"""
        return jnp.eye(self.n)
    
    def inverse(self, g):
        """é€†å…ƒ = é€†çŸ©é˜µ"""
        return jnp.linalg.inv(g)
```

---

### 8. æç¾¤ä¸æä»£æ•°ï¼šç¾¤çš„ã€Œæ— ç©·å°ç‰ˆæœ¬ã€

```
                æç¾¤ G â†â”€â”€â”€â”€â”€â”€â†’ æä»£æ•° ğ”¤
                 â”‚                  â”‚
              ã€Œå…¨å±€ã€           ã€Œå±€éƒ¨/åˆ‡ç©ºé—´ã€
              æœ‰é™å˜æ¢           æ— ç©·å°å˜æ¢
                 â”‚                  â”‚
              çŸ©é˜µä¹˜æ³•          çŸ©é˜µåŠ æ³•+ææ‹¬å·
              
    
    æŒ‡æ•°æ˜ å°„ exp: ğ”¤ â†’ G     ï¼ˆå±€éƒ¨ â†’ å…¨å±€ï¼‰
    å¯¹æ•°æ˜ å°„ log: G â†’ ğ”¤     ï¼ˆå…¨å±€ â†’ å±€éƒ¨ï¼‰
    
    
    ä¾‹ï¼šæ—‹è½¬ç¾¤ SO(3)
    
    æç¾¤ SO(3)              æä»£æ•° ğ”°ğ”¬(3)
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ æ—‹è½¬çŸ©é˜µ â”‚ â†â”€â”€logâ”€â”€â†’ â”‚åå¯¹ç§°çŸ©é˜µâ”‚
    â”‚  R^TR=I â”‚            â”‚  A=-A^T â”‚
    â”‚  det=1  â”‚ â”€â”€expâ”€â”€â†’  â”‚         â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```python
# æç¾¤ â†” æä»£æ•° çš„è½¬æ¢

def so3_exp(omega):
    """
    æŒ‡æ•°æ˜ å°„ï¼šğ”°ğ”¬(3) â†’ SO(3)
    åå¯¹ç§°çŸ©é˜µ â†’ æ—‹è½¬çŸ©é˜µ (Rodrigueså…¬å¼)
    """
    theta = jnp.linalg.norm(omega)
    if theta < 1e-8:
        return jnp.eye(3)
    
    K = jnp.array([
        [0, -omega[2], omega[1]],
        [omega[2], 0, -omega[0]],
        [-omega[1], omega[0], 0]
    ]) / theta
    
    return jnp.eye(3) + jnp.sin(theta) * K + (1 - jnp.cos(theta)) * K @ K

def so3_log(R):
    """
    å¯¹æ•°æ˜ å°„ï¼šSO(3) â†’ ğ”°ğ”¬(3)
    æ—‹è½¬çŸ©é˜µ â†’ åå¯¹ç§°çŸ©é˜µ
    """
    theta = jnp.arccos(jnp.clip((jnp.trace(R) - 1) / 2, -1, 1))
    if theta < 1e-8:
        return jnp.zeros(3)
    
    omega = theta / (2 * jnp.sin(theta)) * jnp.array([
        R[2, 1] - R[1, 2],
        R[0, 2] - R[2, 0],
        R[1, 0] - R[0, 1]
    ])
    return omega
```

---




## é€ŸæŸ¥è¡¨ï¼šèŒƒç•´è®º â†” çº¿æ€§ä»£æ•° â†” CorAtt

| èŒƒç•´è®ºæ¦‚å¿µ | çº¿æ€§ä»£æ•°å¯¹åº” | CorAttä¸­çš„å®ç° |
|-----------|-------------|---------------|
| **å¯¹è±¡** | å‘é‡ç©ºé—´ â„â¿ | ç›¸å…³çŸ©é˜µæµå½¢ Corrâºâºâ‚™ |
| **æ€å°„** | çº¿æ€§æ˜ å°„/çŸ©é˜µ | ç›¸å…³çŸ©é˜µï¼ˆæç¾¤å…ƒç´ ï¼‰ |
| **æ€å°„ç»„åˆ** | çŸ©é˜µä¹˜æ³• | ç¾¤ä¹˜æ³• Expo(Logo(Câ‚)+Logo(Câ‚‚)) |
| **æ’ç­‰æ€å°„** | å•ä½çŸ©é˜µ | å•ä½çŸ©é˜µ Iâ‚™ |
| **å‡½å­** | çº¿æ€§ç®—å­ | æç¾¤åŒæ€ hom(Â·) |
| **è‡ªç„¶å˜æ¢** | åŸºå˜æ¢ | ä¸åŒåº¦é‡é—´çš„è½¬æ¢ |
| **æé™/ä½™æé™** | äº¤é›†/ç›´å’Œ | åŠ æƒFrÃ©chetå‡å€¼ |
| **é—å¿˜å‡½å­** | æŠ•å½± | åˆ‡ç©ºé—´æ˜ å°„ TangentLog |
| **è‡ªç”±å‡½å­** | åµŒå…¥ | æ•°æ®â†’ç›¸å…³çŸ©é˜µ |

éœ€è¦æˆ‘è¯¦ç»†è§£é‡ŠæŸä¸ªéƒ¨åˆ†ï¼Œæˆ–è€…è¡¥å……æ•°æ®åŠ è½½å’Œå®Œæ•´è®­ç»ƒå¾ªç¯çš„ä»£ç å—ï¼Ÿ