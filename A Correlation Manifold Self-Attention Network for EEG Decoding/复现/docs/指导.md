è®©æˆ‘ç”¨ç½‘ç»œæœç´¢æ¥æ‰¾è¿™ç¯‡å…·ä½“çš„è®ºæ–‡ï¼šæ‰¾åˆ°äº†ï¼è¿™æ˜¯IJCAI 2025çš„è®ºæ–‡ã€‚è®©æˆ‘è·å–å®Œæ•´çš„PDFæ¥è¯¦ç»†åˆ†æï¼šæˆ‘å·²ç»è·å–äº†å®Œæ•´çš„è®ºæ–‡å†…å®¹ã€‚è®©æˆ‘ä¸ºä½ æ€»ç»“å¹¶ç»™å‡ºJAXå¤ç°æŒ‡å—ã€‚

---

## ğŸ“„ è®ºæ–‡å„éƒ¨åˆ†ä¸€å¥è¯æ€»ç»“

| éƒ¨åˆ† | ä¸€å¥è¯æ€»ç»“ |
|------|-----------|
| **Abstract** | æå‡ºCorAttç½‘ç»œï¼Œé¦–æ¬¡å°†æ³¨æ„åŠ›æœºåˆ¶æ¨å¹¿åˆ°å…¨ç§©ç›¸å…³çŸ©é˜µæµå½¢ï¼ˆCorrelation Manifoldï¼‰ï¼Œç”¨äºEEGè§£ç ã€‚ |
| **Introduction** | ç›¸å…³çŸ©é˜µå…·æœ‰å°ºåº¦ä¸å˜æ€§ï¼Œæ¯”åæ–¹å·®çŸ©é˜µæ›´é€‚åˆEEGåˆ†æï¼Œä½†ç°æœ‰æ–¹æ³•ç¼ºä¹é’ˆå¯¹ç›¸å…³çŸ©é˜µæµå½¢çš„ç¥ç»ç½‘ç»œè®¾è®¡ã€‚ |
| **Preliminary** | ä»‹ç»æç¾¤ã€æåŒæ€ã€ä»¥åŠå…¨ç§©ç›¸å…³çŸ©é˜µæµå½¢ä¸Šçš„ä¸¤ç§é»æ›¼åº¦é‡ï¼šOff-Log Metric (OLM) å’Œ Log-Scaled Metric (LSM)ã€‚ |
| **Method (3.1)** | è®¾è®¡ç›¸å…³çŸ©é˜µæ³¨æ„åŠ›æœºåˆ¶ï¼šç”¨æç¾¤åŒæ€åšå˜æ¢å±‚ã€æµ‹åœ°è·ç¦»è®¡ç®—ç›¸ä¼¼åº¦ã€åŠ æƒFrÃ©chetå‡å€¼åšç‰¹å¾èšåˆã€‚ |
| **Method (3.2-3.3)** | åˆ†åˆ«åœ¨OLMå’ŒLSMå‡ ä½•ä¸‹æ¨å¯¼äº†æç¾¤åŒæ€å˜æ¢å’ŒåŠ æƒFrÃ©chetå‡å€¼çš„é—­å¼è§£ã€‚ |
| **Method (3.4)** | ç”¨é»æ›¼å¯¹æ•°æ˜ å°„å°†ç›¸å…³çŸ©é˜µæŠ•å½±åˆ°åˆ‡ç©ºé—´ï¼ˆå‘é‡åŒ–åæ¥FCå±‚ï¼‰è¿›è¡Œåˆ†ç±»ã€‚ |
| **Experiments** | åœ¨ä¸‰ä¸ªEEGæ•°æ®é›†ï¼ˆMIã€SSVEPã€ERNï¼‰ä¸Šè¶…è¶Šç°æœ‰SOTAæ–¹æ³•ï¼Œæ¶ˆèå®éªŒéªŒè¯å„ç»„ä»¶æœ‰æ•ˆæ€§ã€‚ |
| **Conclusion** | é¦–æ¬¡åœ¨ç›¸å…³çŸ©é˜µæµå½¢ä¸Šæ„å»ºæ·±åº¦å­¦ä¹ æ¨¡å‹ï¼Œä¸ºæœªæ¥å‡ ä½•æ·±åº¦å­¦ä¹ æ–¹æ³•å¼€è¾Ÿæ–°æ–¹å‘ã€‚ |

---

## ğŸ”§ JAX å¤ç°æŒ‡å—

### 1. æ•´ä½“æ¶æ„

```
è¾“å…¥EEG â†’ å·ç§¯ç‰¹å¾æå–(FEM) â†’ åˆ†å‰²+è®¡ç®—ç›¸å…³çŸ©é˜µ(MMM) â†’ ç›¸å…³çŸ©é˜µæ³¨æ„åŠ› â†’ åˆ‡ç©ºé—´æ˜ å°„ â†’ FCåˆ†ç±»
```

### 2. æ ¸å¿ƒæ¨¡å—å®ç°

#### (A) ç›¸å…³çŸ©é˜µè®¡ç®—
```python
import jax.numpy as jnp

def compute_correlation(X):
    """ä»ç‰¹å¾è®¡ç®—å…¨ç§©ç›¸å…³çŸ©é˜µ C = D^{-1/2} P D^{-1/2}"""
    # X: (batch, channels, time)
    cov = jnp.cov(X)  # åæ–¹å·®çŸ©é˜µ
    d = jnp.sqrt(jnp.diag(cov))
    D_inv_sqrt = jnp.diag(1.0 / d)
    C = D_inv_sqrt @ cov @ D_inv_sqrt
    return C
```

#### (B) OLM å‡ ä½•æ“ä½œ
```python
from jax.scipy.linalg import logm, expm

def off_diag(X):
    """æå–éå¯¹è§’å…ƒç´ """
    return X - jnp.diag(jnp.diag(X))

def logo(C):
    """OLM: C -> Hol(n)"""
    return off_diag(logm(C))

def expo(S):
    """OLM: Hol(n) -> C++, éœ€è¦è¿­ä»£æ±‚è§£å¯¹è§’ä¿®æ­£é¡¹D^o"""
    # å›ºå®šç‚¹è¿­ä»£æ±‚è§£ D^o(S)
    D = jnp.zeros(S.shape[0])
    for _ in range(10):  # è¿­ä»£æ¬¡æ•°
        M = expm(S + jnp.diag(D))
        D = D - jnp.log(jnp.diag(M))
    return expm(S + jnp.diag(D))

def geodesic_distance_olm(C1, C2):
    """OLMæµ‹åœ°è·ç¦»"""
    return jnp.linalg.norm(logo(C1) - logo(C2), 'fro')
```

#### (C) LSM å‡ ä½•æ“ä½œ
```python
def log_star(C):
    """LSM: C -> Row0(n), éœ€è¿­ä»£æ±‚è§£D*(C)"""
    n = C.shape[0]
    # é˜»å°¼ç‰›é¡¿æ³•æ±‚è§£ D*
    x = jnp.ones(n)
    for _ in range(10):
        Cx = C @ x
        f = Cx - 1.0/x
        # ç‰›é¡¿æ­¥
        df = C + jnp.diag(1.0/(x**2))
        x = x - jnp.linalg.solve(df, f) * 0.5
    D_star = jnp.diag(x)
    return logm(D_star @ C @ D_star)

def exp_star(S):
    """LSM: Row0(n) -> C++"""
    P = expm(S)
    return compute_correlation_from_cov(P)  # Cor(exp(S))
```

#### (D) æç¾¤åŒæ€å˜æ¢å±‚
```python
def hom_olm(C, M):
    """OLMæç¾¤åŒæ€: å…¬å¼(11)"""
    # M: æ­£äº¤çŸ©é˜µ (éœ€è¦Cayleyå‚æ•°åŒ–)
    return expo(off_diag(M.T @ logo(C) @ M))

def hom_lsm(C, M):
    """LSMæç¾¤åŒæ€: å…¬å¼(13)"""
    X = M.T @ log_star(C) @ M
    phi_X = X - jnp.diag(X @ jnp.ones(X.shape[0]))  # å…¬å¼(14)
    return exp_star(phi_X)

def cayley_orthogonal(A):
    """Cayleyå‚æ•°åŒ–ç”Ÿæˆæ­£äº¤çŸ©é˜µ: O = (I-S)(I+S)^{-1}"""
    S = A - A.T  # åå¯¹ç§°çŸ©é˜µ
    I = jnp.eye(A.shape[0])
    return jnp.linalg.solve(I + S, I - S)
```

#### (E) ç›¸å…³çŸ©é˜µæ³¨æ„åŠ›
```python
from jax.nn import softmax

def correlation_attention(X_list, hom_fn, geodesic_fn, wfm_fn):
    """
    X_list: list of correlation matrices
    """
    N = len(X_list)
    
    # ç”Ÿæˆ Q, K, V
    Q = [hom_fn(X) for X in X_list]
    K = [hom_fn(X) for X in X_list]
    V = [hom_fn(X) for X in X_list]
    
    outputs = []
    for i in range(N):
        # è®¡ç®—æ³¨æ„åŠ›æƒé‡: å…¬å¼(8)
        scores = []
        for j in range(N):
            d = geodesic_fn(Q[i], K[j])
            s = 1.0 / (1.0 + jnp.log(1.0 + d))
            scores.append(s)
        A = softmax(jnp.array(scores))
        
        # åŠ æƒFrÃ©chetå‡å€¼èšåˆ: å…¬å¼(10)
        R_i = wfm_fn(A, V)
        outputs.append(R_i)
    
    return outputs
```

#### (F) åŠ æƒFrÃ©chetå‡å€¼ (WFM)
```python
def wfm_olm(weights, C_list):
    """OLMä¸‹çš„WFM: å…¬å¼(12)"""
    weighted_sum = sum(w * logo(C) for w, C in zip(weights, C_list))
    return expo(weighted_sum)

def wfm_lsm(weights, C_list):
    """LSMä¸‹çš„WFM: å…¬å¼(15)"""
    weighted_sum = sum(w * log_star(C) for w, C in zip(weights, C_list))
    return exp_star(weighted_sum)
```

#### (G) åˆ‡ç©ºé—´åˆ†ç±»å±‚
```python
def tangent_mapping_olm(C):
    """OLMåˆ‡ç©ºé—´æ˜ å°„: å…¬å¼(16)"""
    return off_diag(logm(C))

def tangent_mapping_lsm(C):
    """LSMåˆ‡ç©ºé—´æ˜ å°„: å…¬å¼(17)"""
    return off_diag(log_star(C))

def vectorize_symmetric(S):
    """æå–ä¸‹ä¸‰è§’å¹¶å±•å¹³"""
    idx = jnp.tril_indices(S.shape[0], k=-1)
    return S[idx]
```

### 3. å®Œæ•´ç½‘ç»œç»“æ„

```python
import flax.linen as nn

class CorAtt(nn.Module):
    num_classes: int
    num_segments: int = 3
    metric: str = 'olm'  # 'olm' or 'lsm'
    
    @nn.compact
    def __call__(self, x):
        # 1. Feature Extraction Module (FEM)
        x = nn.Conv(features=22, kernel_size=(1, 22))(x)  # Spatial conv
        x = nn.Conv(features=20, kernel_size=(1, 25))(x)  # Temporal conv
        
        # 2. Manifold Modeling Module (MMM)
        segments = jnp.array_split(x, self.num_segments, axis=-1)
        corr_matrices = [compute_correlation(seg) for seg in segments]
        
        # 3. Correlation Attention
        if self.metric == 'olm':
            M = self.param('M', nn.initializers.orthogonal(), (20, 20))
            M_orth = cayley_orthogonal(M)
            hom_fn = lambda C: hom_olm(C, M_orth)
            attended = correlation_attention(corr_matrices, hom_fn, 
                                            geodesic_distance_olm, wfm_olm)
        else:  # lsm
            # ç±»ä¼¼å®ç°...
            pass
        
        # 4. Tangent Mapping
        tangent_vecs = [tangent_mapping_olm(C) for C in attended]
        features = jnp.concatenate([vectorize_symmetric(t) for t in tangent_vecs])
        
        # 5. Classification
        logits = nn.Dense(self.num_classes)(features)
        return logits
```

### 4. å…³é”®å®ç°ç»†èŠ‚

| ç»†èŠ‚ | è¯´æ˜ |
|------|------|
| **æ­£äº¤çº¦æŸ** | ç”¨Cayleyå‚æ•°åŒ– `O = (I-S)(I+S)^{-1}` ä¿è¯Mæ­£äº¤ |
| **æ•°å€¼ç¨³å®š** | `logm/expm` éœ€è¦æ­£åˆ™åŒ–ï¼Œå¯åŠ å°é‡ `+ ÎµI` |
| **è¿­ä»£æ±‚è§£** | `expo`å’Œ`log_star`ä¸­çš„ä¸åŠ¨ç‚¹è¿­ä»£ç”¨`jax.lax.fori_loop` |
| **æ‰¹å¤„ç†** | ç”¨`jax.vmap`å¤„ç†batchç»´åº¦ |
| **è¶…å‚æ•°** | MI: 3æ®µ, 25Ã—25å˜æ¢; SSVEP: 7æ®µ, 15Ã—15; ERN: 3æ®µ, 14Ã—14 |

### 5. å‚è€ƒä»£ç åº“

å®˜æ–¹PyTorchå®ç°: https://github.com/ChenHuML/CorAtt

å¦‚æœä½ éœ€è¦ï¼Œæˆ‘å¯ä»¥å¸®ä½ å†™ä¸€ä¸ªæ›´å®Œæ•´çš„JAXå®ç°æ–‡ä»¶ï¼