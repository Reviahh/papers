## 第三部分：CorAtt论文的范畴论架构

### 9. 论文核心思想的范畴论表达

```
┌─────────────────────────────────────────────────────────────────┐
│                    CorAtt 的范畴论架构                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   输入范畴              中间范畴              输出范畴            │
│   ┌─────┐              ┌─────┐              ┌─────┐            │
│   │ EEG │              │Corr │              │ ℝⁿ  │            │
│   │信号 │  ──FEM+MMM─→ │流形 │  ──TanMap──→ │向量 │  ──FC──→ 类别│
│   └─────┘              └─────┘              └─────┘            │
│                            │                                    │
│                      CorAtt注意力                                │
│                      (流形上的自函子)                             │
│                                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│   关键数学结构：                                                  │
│                                                                 │
│   1. Corr⁺⁺ₙ = 全秩相关矩阵流形（李群）                           │
│   2. OLM/LSM = 流形上的黎曼度量                                   │
│   3. 李群同态 = 保结构的变换层                                    │
│   4. 加权Fréchet均值 = 流形上的「平均」                           │
│   5. 切空间投影 = 流形 → 欧氏空间                                 │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 10. 相关矩阵流形作为李群范畴

```
            相关矩阵流形 Corr⁺⁺ₙ 的范畴结构
    
    对象：只有一个点 •（因为是群）
    
    态射：全秩相关矩阵 C ∈ Corr⁺⁺ₙ
    
    组合：群乘法（取决于度量）
    
         OLM: C₁ ⊙ C₂ = Expo(Logo(C₁) + Logo(C₂))
         LSM: C₁ ⊙ C₂ = Exp⋆(Log⋆(C₁) + Log⋆(C₂))
    
    恒等：单位矩阵 Iₙ
    
    逆元：C⁻¹_⊙ 使得 C ⊙ C⁻¹_⊙ = Iₙ
```

```python
class CorrelationManifold:
    """
    相关矩阵流形 Corr⁺⁺ₙ
    范畴论视角：单对象范畴（李群）
    """
    
    def __init__(self, n, metric='olm'):
        self.n = n
        self.metric = metric
    
    # ================== 基础映射 ==================
    
    def logo(self, C):
        """OLM: Corr → Hol(n) (对数映射到李代数)"""
        log_C = jax.scipy.linalg.logm(C)
        return log_C - jnp.diag(jnp.diag(log_C))  # 去对角
    
    def expo(self, S):
        """OLM: Hol(n) → Corr (指数映射回李群)"""
        # 需要迭代求解对角修正项
        D = jnp.zeros(self.n)
        for _ in range(20):
            M = jax.scipy.linalg.expm(S + jnp.diag(D))
            D = D - jnp.log(jnp.diag(M))
        return jax.scipy.linalg.expm(S + jnp.diag(D))
    
    def log_star(self, C):
        """LSM: Corr → Row0(n)"""
        # 阻尼牛顿法求D*
        x = jnp.ones(self.n)
        for _ in range(20):
            Cx = C @ x
            f = Cx - 1.0/x
            J = C + jnp.diag(1.0/(x**2))
            x = x - 0.5 * jnp.linalg.solve(J, f)
        D_star = jnp.diag(x)
        return jax.scipy.linalg.logm(D_star @ C @ D_star)
    
    def exp_star(self, S):
        """LSM: Row0(n) → Corr"""
        P = jax.scipy.linalg.expm(S)
        # 转换为相关矩阵
        d = jnp.sqrt(jnp.diag(P))
        D_inv = jnp.diag(1.0/d)
        return D_inv @ P @ D_inv
    
    # ================== 群操作（态射组合）==================
    
    def compose(self, C1, C2):
        """群乘法 = 态射组合"""
        if self.metric == 'olm':
            return self.expo(self.logo(C1) + self.logo(C2))
        else:  # lsm
            return self.exp_star(self.log_star(C1) + self.log_star(C2))
    
    def identity(self):
        """恒等态射 = 单位矩阵"""
        return jnp.eye(self.n)
    
    def inverse(self, C):
        """逆元"""
        if self.metric == 'olm':
            return self.expo(-self.logo(C))
        else:
            return self.exp_star(-self.log_star(C))
    
    # ================== 测地距离 ==================
    
    def distance(self, C1, C2):
        """测地距离 = 李代数中的欧氏距离"""
        if self.metric == 'olm':
            return jnp.linalg.norm(self.logo(C1) - self.logo(C2), 'fro')
        else:
            return jnp.linalg.norm(self.log_star(C1) - self.log_star(C2), 'fro')
```

---

### 11. 李群同态：范畴之间的函子

**论文的核心创新**：设计保持李群结构的变换层

```
                    李群同态 hom: (Corr⁺⁺ₙ, ⊙) → (Corr⁺⁺ₘ, ⊙)
    
    要求（函子公理）：
    
    1. hom(C₁ ⊙ C₂) = hom(C₁) ⊙ hom(C₂)    保持群乘法
    2. hom(Iₙ) = Iₘ                          保持单位元
    
    
    OLM同态（公式11）：
    ┌──────────────────────────────────────────────────────┐
    │  hom_ol(C) = Expo( Off( Mᵀ · Logo(C) · M ) )        │
    │                                                      │
    │  其中 M ∈ O(n,m) 是正交矩阵（可学习参数）             │
    └──────────────────────────────────────────────────────┘
    
    
    为什么这保持群结构？
    
    hom(C₁ ⊙ C₂) = hom(Expo(Logo(C₁) + Logo(C₂)))
                 = Expo(Off(Mᵀ(Logo(C₁) + Logo(C₂))M))
                 = Expo(Off(MᵀLogo(C₁)M) + Off(MᵀLogo(C₂)M))
                 = Expo(Off(MᵀLogo(C₁)M)) ⊙ Expo(Off(MᵀLogo(C₂)M))
                 = hom(C₁) ⊙ hom(C₂) ✓
```

```python
class LieGroupHomomorphism:
    """
    李群同态：保结构的神经网络层
    范畴论视角：Corr⁺⁺ₙ → Corr⁺⁺ₘ 的函子
    """
    
    def __init__(self, n, m, metric='olm'):
        self.n = n
        self.m = m
        self.metric = metric
        self.manifold_n = CorrelationManifold(n, metric)
        self.manifold_m = CorrelationManifold(m, metric)
    
    def init_params(self, key):
        """初始化正交矩阵参数"""
        # 使用Cayley参数化
        A = jax.random.normal(key, (self.n, self.m))
        return {'A': A}
    
    def get_orthogonal(self, params):
        """Cayley参数化：A → 正交矩阵 M"""
        A = params['A']
        S = A - A.T  # 反对称
        I = jnp.eye(self.n)
        # M = (I - S)(I + S)⁻¹
        return jnp.linalg.solve(I + S, I - S)[:, :self.m]
    
    def __call__(self, C, params):
        """
        应用李群同态
        
        数学：hom(C) = Expo(Off(Mᵀ Logo(C) M))
        范畴论：这是一个函子！
        """
        M = self.get_orthogonal(params)
        
        if self.metric == 'olm':
            log_C = self.manifold_n.logo(C)
            transformed = M.T @ log_C @ M
            off_transformed = transformed - jnp.diag(jnp.diag(transformed))
            return self.manifold_m.expo(off_transformed)
        else:  # lsm
            log_C = self.manifold_n.log_star(C)
            transformed = M.T @ log_C @ M
            # φ操作：减去行和对角
            row_sum = transformed @ jnp.ones(self.m)
            phi_transformed = transformed - jnp.diag(row_sum)
            return self.manifold_m.exp_star(phi_transformed)
    
    def verify_homomorphism(self, C1, C2, params):
        """验证函子公理：hom(C1⊙C2) = hom(C1)⊙hom(C2)"""
        # 左边
        C1_compose_C2 = self.manifold_n.compose(C1, C2)
        left = self(C1_compose_C2, params)
        
        # 右边
        hom_C1 = self(C1, params)
        hom_C2 = self(C2, params)
        right = self.manifold_m.compose(hom_C1, hom_C2)
        
        error = jnp.linalg.norm(left - right, 'fro')
        print(f"函子公理误差: {error:.2e}")
        return error < 1e-6
```

---

### 12. 加权Fréchet均值：范畴极限的流形版本

```
                    Fréchet均值 = 流形上的「范畴积」
    
    欧氏空间中：      流形上：
    
    加权平均           加权Fréchet均值
    ∑ wᵢxᵢ            argmin ∑ wᵢ d²(P, Cᵢ)
                           P∈M
    
    
    OLM下的闭式解（定理3.2）：
    ┌──────────────────────────────────────────────────────┐
    │  WFM({wᵢ}, {Cᵢ}) = Expo( ∑ wᵢ Logo(Cᵢ) )           │
    │                                                      │
    │  这正是李代数中的加权平均，再映射回李群！              │
    └──────────────────────────────────────────────────────┘
    
    
    几何直觉：
    
              C₁ ●
                  \  w₁
                   \
                    ● WFM (测地重心)
                   /
                  /  w₂
              C₂ ●
```

```python
class WeightedFrechetMean:
    """
    加权Fréchet均值
    范畴论视角：带权重的范畴极限
    """
    
    def __init__(self, metric='olm'):
        self.metric = metric
    
    def __call__(self, weights, matrices, manifold):
        """
        计算加权Fréchet均值
        
        weights: [w₁, w₂, ..., wₙ], 和为1
        matrices: [C₁, C₂, ..., Cₙ], 相关矩阵列表
        """
        # 归一化权重
        weights = jnp.array(weights)
        weights = weights / jnp.sum(weights)
        
        if self.metric == 'olm':
            # WFM = Expo(∑ wᵢ Logo(Cᵢ))
            weighted_sum = sum(
                w * manifold.logo(C) 
                for w, C in zip(weights, matrices)
            )
            return manifold.expo(weighted_sum)
        else:  # lsm
            # WFM = Exp⋆(∑ wᵢ Log⋆(Cᵢ))
            weighted_sum = sum(
                w * manifold.log_star(C) 
                for w, C in zip(weights, matrices)
            )
            return manifold.exp_star(weighted_sum)
```

---

### 13. 切空间投影：遗忘函子

```
                切空间投影 = 遗忘函子 U: Corr⁺⁺ₙ → Vect
    
    从「丰富结构」到「简单结构」的映射
    
    
         Corr⁺⁺ₙ (李群)              Hol(n) ≅ ℝ^(n(n-1)/2) (向量空间)
              │                              │
              │      Log_Iₙ                  │
              │   (黎曼对数映射)              │
              ↓                              ↓
              C  ─────────────→  Off(log(C)) ─────→ vec(·) → 向量
    
    
    这「遗忘」了流形的弯曲几何，只保留切空间的线性结构
```

```python
class TangentProjection:
    """
    切空间投影：流形 → 欧氏向量空间
    范畴论视角：遗忘函子
    """
    
    def __init__(self, metric='olm'):
        self.metric = metric
    
    def __call__(self, C, manifold):
        """
        投影到切空间并向量化
        
        1. 计算黎曼对数（投影到切空间）
        2. 提取下三角并展平
        """
        if self.metric == 'olm':
            # Log^ol_I(C) = Off(log(C))
            tangent = manifold.logo(C)
        else:
            # Log^ls_I(C) = Off(Log⋆(C))
            log_star_C = manifold.log_star(C)
            tangent = log_star_C - jnp.diag(jnp.diag(log_star_C))
        
        # 向量化下三角
        idx = jnp.tril_indices(C.shape[0], k=-1)
        return tangent[idx]
    
    def output_dim(self, n):
        """输出向量维度"""
        return n * (n - 1) // 2
```

---

### 14. 完整的CorAtt范畴论架构

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         CorAtt 完整范畴论架构图                              │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│   ℝ^(C×T)  ────FEM────→  ℝ^(D×T)  ────Split────→  [ℝ^(D×T/s)]              │
│   (EEG信号)    卷积         特征         分段         段列表                │
│                                                                             │
│       │                                    │                                │
│       │                            Cor(·)  │  协方差→相关矩阵               │
│       │                                    ↓                                │
│       │                                                                     │
│       │                           [C₁, C₂, ..., Cₛ]                        │
│       │                            相关矩阵列表                             │
│       │                                    │                                │
│       │                                    │                                │
│       │         ┌──────────────────────────┼──────────────────────────┐     │
│       │         │      Correlation Attention (自函子)                 │     │
│       │         │                          │                          │     │
│       │         │    ┌─────────────────────┼─────────────────────┐   │     │
│       │         │    │                     │                     │   │     │
│       │         │    │   Q = hom(C)    K = hom(C)    V = hom(C)  │   │     │
│       │         │    │       │             │             │       │   │     │
│       │         │    │       │    d(Q,K)   │             │       │   │     │
│       │         │    │       └─────┬───────┘             │       │   │     │
│       │         │    │             │                     │       │   │     │
│       │         │    │        Attention                  │       │   │     │
│       │         │    │         Weights                   │       │   │     │
│       │         │    │             │                     │       │   │     │
│       │         │    │             └──────┬──────────────┘       │   │     │
│       │         │    │                    │                      │   │     │
│       │         │    │               WFM(A, V)                   │   │     │
│       │         │    │                    │                      │   │     │
│       │         │    └────────────────────┼──────────────────────┘   │     │
│       │         │                         │                          │     │
│       │         │                    [R₁, ..., Rₛ]                   │     │
│       │         │                    精炼后的相关矩阵                 │     │
│       │         └─────────────────────────┼──────────────────────────┘     │
│       │                                   │                                │
│       │                                   │                                │
│       │                          TangentProjection                         │
│       │                          (遗忘函子)                                 │
│       │                                   │                                │
│       │                                   ↓                                │
│       │                                                                     │
│       │                           [v₁, ..., vₛ]                            │
│       │                            切向量列表                               │
│       │                                   │                                │
│       │                            Concatenate                             │
│       │                                   │                                │
│       │                                   ↓                                │
│       │                                                                     │
│       │                               v ∈ ℝⁿ                               │
│       │                             特征向量                                │
│       │                                   │                                │
│       │                              FC + Softmax                          │
│       │                                   │                                │
│       ↓                                   ↓                                │
│                                                                             │
│   输入空间                             输出空间                             │
│   (欧氏)                               (概率单纯形)                         │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

